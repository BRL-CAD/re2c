// Code generated by re2c, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT --input-encoding utf8 --loop-switch -i

// This example supports multiple input encodings: UTF-8 and UTF-32.
// Both lexers are generated from the same rules block, and the use
// blocks add only encoding-specific configurations.

package main

import "testing"



func lexUTF8(str []uint8) int {
	var cursor, marker int
	
{
	var yych uint8
	yystate := 1
	for {
		switch (yystate) {
		case 1:
			yych = str[cursor]
			cursor += 1
			switch (yych) {
			case 0xE2:
				yystate = 4
				continue
			default:
				yystate = 2
				continue
			}
		case 2:
			yystate = 3
			continue
		case 3:
			{ return 1; }
		case 4:
			marker = cursor
			yych = str[cursor]
			switch (yych) {
			case 0x88:
				cursor += 1
				yystate = 5
				continue
			default:
				yystate = 3
				continue
			}
		case 5:
			yych = str[cursor]
			switch (yych) {
			case 0x80:
				cursor += 1
				yystate = 7
				continue
			default:
				yystate = 6
				continue
			}
		case 6:
			cursor = marker
			yystate = 3
			continue
		case 7:
			yych = str[cursor]
			switch (yych) {
			case 'x':
				cursor += 1
				yystate = 8
				continue
			default:
				yystate = 6
				continue
			}
		case 8:
			yych = str[cursor]
			switch (yych) {
			case ' ':
				cursor += 1
				yystate = 9
				continue
			default:
				yystate = 6
				continue
			}
		case 9:
			yych = str[cursor]
			switch (yych) {
			case 0xE2:
				cursor += 1
				yystate = 10
				continue
			default:
				yystate = 6
				continue
			}
		case 10:
			yych = str[cursor]
			switch (yych) {
			case 0x88:
				cursor += 1
				yystate = 11
				continue
			default:
				yystate = 6
				continue
			}
		case 11:
			yych = str[cursor]
			switch (yych) {
			case 0x83:
				cursor += 1
				yystate = 12
				continue
			default:
				yystate = 6
				continue
			}
		case 12:
			yych = str[cursor]
			switch (yych) {
			case 'y':
				cursor += 1
				yystate = 13
				continue
			default:
				yystate = 6
				continue
			}
		case 13:
			yystate = 14
			continue
		case 14:
			{ return 0; }
		}
	}
}

}

func lexUTF32(str []uint32) int {
	var cursor, marker int
	
{
	var yych uint32
	yystate := 16
	for {
		switch (yystate) {
		case 16:
			yych = str[cursor]
			cursor += 1
			if (yych == 0x00002200) {
				yystate = 19
				continue
			}
			yystate = 17
			continue
		case 17:
			yystate = 18
			continue
		case 18:
			{ return 1; }
		case 19:
			marker = cursor
			yych = str[cursor]
			if (yych != 'x') {
				yystate = 18
				continue
			}
			cursor += 1
			yystate = 20
			continue
		case 20:
			yych = str[cursor]
			if (yych == ' ') {
				cursor += 1
				yystate = 22
				continue
			}
			yystate = 21
			continue
		case 21:
			cursor = marker
			yystate = 18
			continue
		case 22:
			yych = str[cursor]
			if (yych != 0x00002203) {
				yystate = 21
				continue
			}
			cursor += 1
			yystate = 23
			continue
		case 23:
			yych = str[cursor]
			if (yych != 'y') {
				yystate = 21
				continue
			}
			cursor += 1
			yystate = 24
			continue
		case 24:
			yystate = 25
			continue
		case 25:
			{ return 0; }
		}
	}
}

}

func TestLex(t *testing.T) {
	s8 := []uint8{0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79};
	if lexUTF8(s8) != 0 {
		t.Errorf("utf8 failed")
	}

	s32 := []uint32{0x2200, 0x78, 0x20, 0x2203, 0x79};
	if lexUTF32(s32) != 0 {
		t.Errorf("utf32 failed")
	}
}
