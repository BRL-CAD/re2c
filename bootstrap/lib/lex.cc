/* Generated by re2c 3.0 on Mon Jun 20 21:34:19 2022 */
#line 1 "../lib/lex.re"
#include <stdio.h>

#include <stdint.h>

#include "src/encoding/enc.h"
#include "src/msg/msg.h"
#include "src/parse/ast.h"
#include "src/parse/unescape.h"
#include "src/util/range.h"
#include "src/util/s_to_n32_unsafe.h"
#include "parse.h"
#include "lib/lex.h"

extern YYSTYPE yylval;

namespace re2c {

static int32_t lex_cls_chr(const char*&, uint32_t&);

#line 29 "../lib/lex.re"


int lex(const char*& cur, Ast& ast) {
    
#line 28 "lib/lex.cc"
const char *yyt1;const char *yyt2;
#line 32 "../lib/lex.re"

    const char* mar, *x, *y;
    bool neg = false;
    uint32_t l, u;


#line 37 "lib/lex.cc"
{
	char yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	yych = *cur;
	if (yych <= '>') {
		if (yych <= '\'') {
			if (yych <= 0x00) goto yy1;
			if (yych == '$') goto yy4;
			goto yy2;
		} else {
			if (yych <= '+') goto yy5;
			if (yych == '.') goto yy6;
			goto yy2;
		}
	} else {
		if (yych <= ']') {
			if (yych <= '?') goto yy5;
			if (yych == '[') goto yy7;
			goto yy2;
		} else {
			if (yych <= 'z') {
				if (yych <= '^') goto yy4;
				goto yy2;
			} else {
				if (yych <= '{') goto yy8;
				if (yych <= '|') goto yy5;
				goto yy2;
			}
		}
	}
yy1:
	++cur;
#line 40 "../lib/lex.re"
	{ return 0; }
#line 105 "lib/lex.cc"
yy2:
	++cur;
yy3:
#line 75 "../lib/lex.re"
	{
        ast.temp_chars.push_back({static_cast<uint32_t>(cur[-1]), NOWHERE});
        yylval.regexp = ast.str(NOWHERE, false);
        return TOKEN_REGEXP;
    }
#line 115 "lib/lex.cc"
yy4:
	++cur;
#line 44 "../lib/lex.re"
	{
        error("anchors are not supported");
        return TOKEN_ERROR;
    }
#line 123 "lib/lex.cc"
yy5:
	++cur;
#line 42 "../lib/lex.re"
	{ return cur[-1]; }
#line 128 "lib/lex.cc"
yy6:
	++cur;
#line 70 "../lib/lex.re"
	{
        yylval.regexp = ast.dot(NOWHERE);
        return TOKEN_REGEXP;
    }
#line 136 "lib/lex.cc"
yy7:
	yych = *++cur;
	if (yych == '^') goto yy9;
#line 50 "../lib/lex.re"
	{ goto cls; }
#line 142 "lib/lex.cc"
yy8:
	yych = *(mar = ++cur);
	if (yych <= '/') goto yy3;
	if (yych <= '9') {
		yyt1 = cur;
		goto yy10;
	}
	goto yy3;
yy9:
	++cur;
#line 49 "../lib/lex.re"
	{ neg = true; goto cls; }
#line 155 "lib/lex.cc"
yy10:
	yych = *++cur;
	if (yybm[0+yych] & 128) {
		goto yy10;
	}
	if (yych == ',') goto yy12;
	if (yych == '}') goto yy13;
yy11:
	cur = mar;
	goto yy3;
yy12:
	yych = *++cur;
	if (yych <= '/') goto yy11;
	if (yych <= '9') {
		yyt2 = cur;
		goto yy14;
	}
	if (yych == '}') goto yy15;
	goto yy11;
yy13:
	++cur;
	x = yyt1;
#line 52 "../lib/lex.re"
	{
        if (!s_to_u32_unsafe(x, cur - 1, yylval.bounds.min)) goto err_cnt;
        yylval.bounds.max = yylval.bounds.min;
        return TOKEN_COUNT;
    }
#line 184 "lib/lex.cc"
yy14:
	yych = *++cur;
	if (yych <= '/') goto yy11;
	if (yych <= '9') goto yy14;
	if (yych == '}') goto yy16;
	goto yy11;
yy15:
	++cur;
	x = yyt1;
#line 64 "../lib/lex.re"
	{
        if (!s_to_u32_unsafe(x, cur - 2, yylval.bounds.min)) goto err_cnt;
        yylval.bounds.max = Ast::MANY;
        return TOKEN_COUNT;
    }
#line 200 "lib/lex.cc"
yy16:
	++cur;
	x = yyt1;
	y = yyt2;
#line 58 "../lib/lex.re"
	{
        if (!s_to_u32_unsafe(x, y - 1, yylval.bounds.min)
            || !s_to_u32_unsafe(y, cur - 1, yylval.bounds.max)) goto err_cnt;
        return TOKEN_COUNT;
    }
#line 211 "lib/lex.cc"
}
#line 80 "../lib/lex.re"


cls:
    if (lex_cls_chr(cur, l) != 0) goto err;

#line 219 "lib/lex.cc"
{
	char yych;
	yych = *(mar = cur);
	if (yych == '-') goto yy19;
yy18:
#line 85 "../lib/lex.re"
	{ u = l; goto add; }
#line 227 "lib/lex.cc"
yy19:
	yych = *++cur;
	if (yych != ']') goto yy20;
	cur = mar;
	goto yy18;
yy20:
	++cur;
	cur -= 1;
#line 86 "../lib/lex.re"
	{ if (lex_cls_chr(cur, u) != 0) goto err; goto add; }
#line 238 "lib/lex.cc"
}
#line 87 "../lib/lex.re"

add:
    if (l > u) goto err;
    ast.temp_ranges.push_back(AstRange(l, u, NOWHERE));

#line 246 "lib/lex.cc"
{
	char yych;
	yych = *cur;
	if (yych == ']') goto yy22;
#line 92 "../lib/lex.re"
	{ goto cls; }
#line 253 "lib/lex.cc"
yy22:
	++cur;
#line 93 "../lib/lex.re"
	{
        yylval.regexp = ast.cls(NOWHERE, neg);
        return TOKEN_REGEXP;
    }
#line 261 "lib/lex.cc"
}
#line 97 "../lib/lex.re"


err:
    error("syntax error: %s\n", cur);
    return TOKEN_ERROR;

err_cnt:
    error("repetition count overflow");
    return TOKEN_ERROR;
}

int32_t lex_cls_chr(const char*& cur, uint32_t& c) {
    const char* mar, *p = cur;

#line 278 "lib/lex.cc"
{
	char yych;
	yych = *cur;
	if (yych <= 0x00) goto yy24;
	if (yych <= 'Z') goto yy25;
	if (yych <= '[') goto yy27;
	if (yych <= '\\') goto yy28;
	goto yy25;
yy24:
	++cur;
#line 111 "../lib/lex.re"
	{ return 1; }
#line 291 "lib/lex.cc"
yy25:
	++cur;
yy26:
#line 129 "../lib/lex.re"
	{ c = static_cast<uint8_t>(cur[-1]); return 0; }
#line 297 "lib/lex.cc"
yy27:
	yych = *++cur;
	if (yych <= '9') {
		if (yych == '.') goto yy30;
		goto yy26;
	} else {
		if (yych <= ':') goto yy31;
		if (yych == '=') goto yy32;
		goto yy26;
	}
yy28:
	yych = *(mar = ++cur);
	switch (yych) {
		case '\\': goto yy33;
		case ']': goto yy34;
		case 'a': goto yy35;
		case 'b': goto yy36;
		case 'f': goto yy37;
		case 'n': goto yy38;
		case 'r': goto yy39;
		case 't': goto yy40;
		case 'v': goto yy41;
		case 'x': goto yy42;
		default: goto yy29;
	}
yy29:
#line 118 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\\');    return 0; }
#line 326 "lib/lex.cc"
yy30:
	++cur;
#line 112 "../lib/lex.re"
	{ error("collating characters not supported"); return 1; }
#line 331 "lib/lex.cc"
yy31:
	++cur;
#line 113 "../lib/lex.re"
	{ error("character classes not supported");    return 1; }
#line 336 "lib/lex.cc"
yy32:
	++cur;
#line 114 "../lib/lex.re"
	{ error("equivalence classes not supported");  return 1; }
#line 341 "lib/lex.cc"
yy33:
	++cur;
#line 126 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\\');    return 0; }
#line 346 "lib/lex.cc"
yy34:
	++cur;
#line 127 "../lib/lex.re"
	{ c = static_cast<uint8_t>(']');     return 0; }
#line 351 "lib/lex.cc"
yy35:
	++cur;
#line 119 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\a');    return 0; }
#line 356 "lib/lex.cc"
yy36:
	++cur;
#line 120 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\b');    return 0; }
#line 361 "lib/lex.cc"
yy37:
	++cur;
#line 121 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\f');    return 0; }
#line 366 "lib/lex.cc"
yy38:
	++cur;
#line 122 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\n');    return 0; }
#line 371 "lib/lex.cc"
yy39:
	++cur;
#line 123 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\r');    return 0; }
#line 376 "lib/lex.cc"
yy40:
	++cur;
#line 124 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\t');    return 0; }
#line 381 "lib/lex.cc"
yy41:
	++cur;
#line 125 "../lib/lex.re"
	{ c = static_cast<uint8_t>('\v');    return 0; }
#line 386 "lib/lex.cc"
yy42:
	yych = *++cur;
	if (yych <= '@') {
		if (yych <= '/') goto yy43;
		if (yych <= '9') goto yy44;
	} else {
		if (yych <= 'F') goto yy44;
		if (yych <= '`') goto yy43;
		if (yych <= 'f') goto yy44;
	}
yy43:
	cur = mar;
	goto yy29;
yy44:
	yych = *++cur;
	if (yych <= '@') {
		if (yych <= '/') goto yy43;
		if (yych >= ':') goto yy43;
	} else {
		if (yych <= 'F') goto yy45;
		if (yych <= '`') goto yy43;
		if (yych >= 'g') goto yy43;
	}
yy45:
	++cur;
#line 116 "../lib/lex.re"
	{ c = unesc_hex(p, cur); return 0; }
#line 414 "lib/lex.cc"
}
#line 130 "../lib/lex.re"

}

} // namespace re2c
