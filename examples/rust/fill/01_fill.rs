/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT

use std::fs::File;
use std::io::{Read, Write};

const SIZE: usize = 4096;

struct State {
    file: File,
    buf: [u8; SIZE],
    lim: usize,
    cur: usize,
    mar: usize,
    tok: usize,
    eof: bool,
}

#[derive(PartialEq)]
enum Fill { Ok, Eof, LongLexeme }

fn fill(st: &mut State) -> Fill {
    if st.eof {
        return Fill::Eof;
    }

    let free = st.tok;
    if free < 1 {
        return Fill::LongLexeme;
    }

    // Shift buffer contents (discard everything up to current token).
    unsafe {
        let p = st.buf.as_mut_ptr();
        std::ptr::copy(p, p.offset(free as isize), st.lim - st.tok);
    }
    // Shift indices accordingly.
    st.lim -= free;
    st.cur -= free;
    st.mar = st.mar.overflowing_sub(free).0; // underflow ok if marker is unused
    st.tok -= free;
    // Fill free space at the end of buffer with new data from file.
    match st.file.read(&mut st.buf[st.lim..(st.lim + free)]) {
        Ok(n) => {
            st.lim += n;
            st.eof = n == 0; // end of file
        }
        Err(why) => panic!("cannot read from file: {}", why)
    }
    // Write sentinel after the last character read from file.
    st.buf[st.lim] = 0;

    return Fill::Ok;
}

fn lex(st: &mut State) -> isize {
    let mut count: isize = 0;

    'lex: loop {
        st.tok = st.cur;
    
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yystate : usize = 0;
	loop {
		match yystate {
			0 => {
				yych = unsafe {*st.buf.get_unchecked(st.cur)};
				match yych {
					0x20 => {
						st.cur += 1;
						yystate = 3;
						continue;
					}
					0x27 => {
						st.cur += 1;
						yystate = 6;
						continue;
					}
					_ => {
						if st.cur + 1 > st.lim {
							if fill(st) == Fill::Ok {
								yystate = 0;
								continue;
							}
							yystate = 12;
							continue;
						}
						st.cur += 1;
						yystate = 1;
						continue;
					}
				}
			}
			1 => {
				yystate = 2;
				continue;
			}
			2 => {
				{ return -1; }
			}
			3 => {
				yych = unsafe {*st.buf.get_unchecked(st.cur)};
				yystate = 4;
				continue;
			}
			4 => {
				match yych {
					0x20 => {
						st.cur += 1;
						yystate = 3;
						continue;
					}
					_ => {
						if st.cur + 1 > st.lim {
							if fill(st) == Fill::Ok {
								yystate = 3;
								continue;
							}
						}
						yystate = 5;
						continue;
					}
				}
			}
			5 => {
				{ continue 'lex; }
			}
			6 => {
				st.mar = st.cur;
				yych = unsafe {*st.buf.get_unchecked(st.cur)};
				if yych >= 0x01 {
					yystate = 8;
					continue;
				}
				if st.cur + 1 > st.lim {
					if fill(st) == Fill::Ok {
						yystate = 6;
						continue;
					}
					yystate = 2;
					continue;
				}
				st.cur += 1;
				yystate = 7;
				continue;
			}
			7 => {
				yych = unsafe {*st.buf.get_unchecked(st.cur)};
				yystate = 8;
				continue;
			}
			8 => {
				match yych {
					0x27 => {
						st.cur += 1;
						yystate = 9;
						continue;
					}
					0x5C => {
						st.cur += 1;
						yystate = 11;
						continue;
					}
					_ => {
						if st.cur + 1 > st.lim {
							if fill(st) == Fill::Ok {
								yystate = 7;
								continue;
							}
							yystate = 13;
							continue;
						}
						st.cur += 1;
						yystate = 7;
						continue;
					}
				}
			}
			9 => {
				yystate = 10;
				continue;
			}
			10 => {
				{ count += 1; continue 'lex; }
			}
			11 => {
				yych = unsafe {*st.buf.get_unchecked(st.cur)};
				if yych <= 0x00 {
					if st.cur + 1 > st.lim {
						if fill(st) == Fill::Ok {
							yystate = 11;
							continue;
						}
						yystate = 13;
						continue;
					}
					st.cur += 1;
					yystate = 7;
					continue;
				}
				st.cur += 1;
				yystate = 7;
				continue;
			}
			12 => {
				{ return count; }
			}
			13 => {
				st.cur = st.mar;
				yystate = 2;
				continue;
			}
			_ => {
				panic!("internal lexer error")
			}
		}
	}
}
}
}

fn main() {
    let fname = "input";
    let mut file: File;

    // Create input file.
    file = match File::create(fname) {
        Err(why) => panic!("cannot open {}: {}", fname, why),
        Ok(file) => file,
    };

    // Prepare input file: a few times the size of the buffer, containing
    // strings with zeroes and escaped quotes.
    let mut count = 0;
    for _ in 0..SIZE {
        match file.write_all(b"'qu\0tes' 'are' 'fine: \\'' ") {
            Err(why) => panic!("cannot write to {}: {}", fname, why),
            Ok(_) => {}
        }
        count += 3;
    }

    // Reopen input file for reading.
    file = match File::open(fname) {
        Err(why) => panic!("cannot read file {}: {}", fname, why),
        Ok(file) => file,
    };

    // Prepare lexer state and fill buffer.
    let lim = SIZE - 1; // one left for the sentinel
    let mut st = State {
        file: file,
        buf: [0; SIZE],
        lim: lim,
        cur: lim,
        mar: lim,
        tok: lim,
        eof: false,
    };
    fill(&mut st);

    // Run the lexer.
    assert_eq!(lex(&mut st), count as isize);

    // Cleanup: remove input file.
    match std::fs::remove_file(fname) {
        Err(why) => panic!("cannot remove {}: {}", fname, why),
        Ok(_) => {}
    }
}
