/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT

// Expect a null-terminated string.
fn lex(s: &[u8]) -> isize {
    let mut cursor = 0;
    let mut count = 0;

    'lex: loop { 
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yystate : usize = 0;
	loop {
		match yystate {
			0 => {
				yych = unsafe {*s.get_unchecked(cursor)};
				cursor += 1;
				match yych {
					0x00 => {
						yystate = 1;
						continue;
					}
					0x20 => {
						yystate = 5;
						continue;
					}
					0x61 ..= 0x7A => {
						yystate = 8;
						continue;
					}
					_ => {
						yystate = 3;
						continue;
					}
				}
			}
			1 => { return count; }
			3 => { return -1; }
			5 => {
				yych = unsafe {*s.get_unchecked(cursor)};
				match yych {
					0x20 => {
						cursor += 1;
						yystate = 5;
						continue;
					}
					_ => {
						yystate = 7;
						continue;
					}
				}
			}
			7 => { continue 'lex; }
			8 => {
				yych = unsafe {*s.get_unchecked(cursor)};
				match yych {
					0x61 ..= 0x7A => {
						cursor += 1;
						yystate = 8;
						continue;
					}
					_ => {
						yystate = 10;
						continue;
					}
				}
			}
			10 => { count += 1; continue 'lex; }
			_ => {
				panic!("internal lexer error")
			}
		}
	}
}
 }
}

fn main() {
    assert_eq!(lex(b"\x00"), 0);
    assert_eq!(lex(b"one two three\x00"), 3);
    assert_eq!(lex(b"f0ur\x00"), -1);
}
